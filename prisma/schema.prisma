// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String    @id @default(uuid())
  stravaId      String?   @unique
  garminId      String?   @unique
  email         String?   @unique
  name          String
  profilePic    String?
  
  // Strava OAuth tokens
  stravaAccessToken   String?
  stravaRefreshToken  String?
  stravaTokenExpiresAt DateTime?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  projects        Project[]
  activities      Activity[]
  streetProgress  UserStreetProgress[]
  edges           UserEdge[]
  nodeHits        UserNodeHit[]
}

// ============================================
// Project Model
// ============================================

model Project {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name            String
  centerLat       Float
  centerLng       Float
  radiusMeters    Int       // Allowed: 500, 1000, 2000, 5000, 10000
  
  // Street snapshot stored as JSON
  // Structure: { streets: SnapshotStreet[], snapshotDate: string }
  streetsSnapshot Json
  snapshotDate    DateTime
  
  // Cached statistics (avoid recalculating on every view)
  totalStreets      Int
  totalLengthMeters Float
  completedStreets  Int       @default(0)
  progress          Float     @default(0)  // 0-100 percentage
  
  deadline        DateTime?
  isArchived      Boolean   @default(false)
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  activities      ProjectActivity[]

  @@index([userId])
  @@index([userId, isArchived])
}

// ============================================
// Activity Model
// ============================================

model Activity {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  stravaId        String    @unique
  name            String
  distanceMeters  Float
  durationSeconds Int
  startDate       DateTime
  activityType    String    @default("Run")
  
  // GPS coordinates from Strava streams
  // Structure: GpxPoint[] (lat, lng, elevation?, timestamp?)
  coordinates     Json
  
  // Processing status
  isProcessed     Boolean   @default(false)
  processedAt     DateTime?
  
  createdAt       DateTime  @default(now())
  
  // Relations
  projects        ProjectActivity[]

  @@index([userId])
  @@index([stravaId])
  @@index([userId, startDate])
}

// ============================================
// ProjectActivity Junction Model
// ============================================

model ProjectActivity {
  id              String    @id @default(uuid())
  projectId       String
  activityId      String
  project         Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  activity        Activity   @relation(fields: [activityId], references: [id], onDelete: Cascade)
  
  // Impact of this activity on the project
  streetsCompleted  Int
  streetsImproved   Int
  
  // Detailed impact breakdown (optional)
  // Structure: { completed: string[], improved: {osmId, from, to}[] }
  impactDetails     Json?
  
  createdAt       DateTime  @default(now())

  @@unique([projectId, activityId])
  @@index([projectId])
  @@index([activityId])
}

// ============================================
// Geometry Cache Model
// ============================================

model GeometryCache {
  id            String    @id @default(uuid())
  
  // Cache key format: "radius:{lat}:{lng}:{meters}" or "bbox:{s}:{w}:{n}:{e}"
  cacheKey      String    @unique
  
  // Cached street geometries (OsmStreet[] with full geometry)
  geometries    Json
  
  createdAt     DateTime  @default(now())
  expiresAt     DateTime

  @@index([cacheKey])
  @@index([expiresAt])
}

// ============================================
// User Street Progress Model
// ============================================
// Tracks user-level street progress across all routes.
// One row per user per street (osmId). Synced when activities are processed.
// Used by the map feature for efficient "all streets I've run" queries.

model UserStreetProgress {
  id            String    @id @default(uuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Street identity (from OpenStreetMap)
  osmId         String    // OSM way ID
  name          String    // Street name (denormalized for display)
  highwayType   String    // e.g. residential, footway
  lengthMeters  Float     // Street length (denormalized)

  // Progress tracking
  percentage    Float     @default(0)   // 0-100, MAX rule applies
  spatialCoverage Json?   // { intervals: [[0, 50], [75, 100]] } - covered portions as percentages
  everCompleted Boolean   @default(false) // Once true, always true

  // Stats for map info icon
  runCount        Int      @default(0)   // Times user ran on this street
  completionCount Int      @default(0)   // Times user achieved >= 90%

  // Timestamps
  firstRunDate  DateTime?
  lastRunDate   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([userId, osmId])
  @@index([userId])
  @@index([userId, percentage])
}

// ============================================
// User Edge Model (Parser-Test: Edge-Based System)
// ============================================
// Stores completed edges per user. Edges are truth, streets are derived.
// One row per edge per user. Edges are normalized (nodeA < nodeB always).

model UserEdge {
  id            String    @id @default(uuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Edge identity (normalized: nodeA < nodeB always)
  edgeId        String    // Format: "{nodeA}-{nodeB}" e.g. "123456-123457"
  nodeA         BigInt    // Smaller OSM node ID
  nodeB         BigInt    // Larger OSM node ID
  
  // Way information (for street derivation)
  wayId         BigInt    // OSM way ID this edge belongs to
  wayName       String?   // Street name (denormalized for display)
  highwayType   String    // e.g. residential, footway
  
  // Edge metadata
  lengthMeters  Float     // Edge length in meters
  
  // Tracking
  firstRunAt    DateTime  // When first completed
  runCount      Int       @default(1) // Times traversed
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([userId, edgeId])  // One edge per user (idempotent)
  @@index([userId])           // Fast: "all edges for user X"
  @@index([userId, wayId])    // Fast: "all edges for user X on way Y"
  @@index([wayId])            // Fast: "all users who completed this way"
}

// ============================================
// Way Cache Model (Parser-Test: Performance Optimization)
// ============================================
// Caches node-to-way mappings to avoid per-run Overpass queries.
// Critical for performance - avoids hitting Overpass API repeatedly.

model WayCache {
  id            String    @id @default(uuid())
  
  // Node to way mapping
  nodeId        BigInt    @unique  // OSM node ID
  wayIds        Json      // Array of way IDs containing this node: [wayId1, wayId2, ...]
  
  // Way metadata (denormalized for fast lookup)
  // Structure: { wayId: { name, highwayType, nodeSequence: [nodeA, nodeB, ...] } }
  wayMetadata   Json
  
  createdAt     DateTime  @default(now())
  expiresAt     DateTime  // Cache expiry (e.g. 30 days)
  
  @@index([nodeId])
  @@index([expiresAt])
}

// ============================================
// Way Total Edges (Parser-Test: Street Completion)
// ============================================
// One row per way: total edge count (nodes.length - 1). Filled by seed script.
// Used to compute isComplete: edgesCompleted >= totalEdges.

model WayTotalEdges {
  wayId       BigInt   @id  // OSM way ID
  totalEdges  Int            // nodes.length - 1 for this way (legacy)
  totalNodes  Int      @default(0)  // node count per way (CityStrides-style completion)
  name        String?         // Denormalized for display
  highwayType String         // e.g. residential, footway
  createdAt   DateTime @default(now())
}

// ============================================
// User Node Hit (CityStrides-Style: Node Proximity)
// ============================================
// Tracks which OSM nodes a user has been within 25m of. One row per user per node (cumulative).

model UserNodeHit {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  nodeId    BigInt
  hitAt     DateTime @default(now())

  @@unique([userId, nodeId])
  @@index([userId])
  @@index([nodeId])
}

// ============================================
// Way Node (CityStrides-Style: Way-to-Node Mapping)
// ============================================
// Maps each way to its constituent nodes. Populated by seed script for completion queries.

model WayNode {
  wayId   BigInt
  nodeId  BigInt

  @@id([wayId, nodeId])
  @@index([nodeId])
}

// ============================================
// Node Cache (Local Map-Matcher: Node Coordinates)
// ============================================
// Stores node coordinates from PBF for local map-matching.
// Only stores nodes that belong to runnable ways (referenced by ways).
// Used by node proximity (25m snap) and previously by local map-matcher.

model NodeCache {
  nodeId    BigInt   @id  // OSM node ID
  lat       Float          // Latitude
  lon       Float          // Longitude
  createdAt DateTime @default(now())

  @@index([lat, lon])  // For bounding box queries (city-level is sufficient)
}